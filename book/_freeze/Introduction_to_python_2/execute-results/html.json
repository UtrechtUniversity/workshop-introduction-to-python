{
  "hash": "83169f2acf2b3348967e831180976228",
  "result": {
    "markdown": "---\ntitle: \"Operators and built-in functions\"\nexecute:   \n  enabled: true\n  error: true\n  freeze: auto\n---\n\n## Mathematical operations\n\nIn Python you can do a wide variety of mathematical operations. A few examples:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nsumming = 2 + 2\nmultiply = 2 * 7\npower = 2 ** 16\nmodulo = 13 % 5\n\nprint(\"Sum: \", summing)\nprint(\"Multiply: \", multiply)\nprint(\"Power: \", power)\nprint(\"Modulo: \", modulo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSum:  4\nMultiply:  14\nPower:  65536\nModulo:  3\n```\n:::\n:::\n\n\nOnce we have data stored in variables, we can use the variables to do calculations.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nnumber = 42\npi_value = 3.14159265358\n\noutput = number * pi_value\nprint(output)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n131.94689145036\n```\n:::\n:::\n\n\n## Built-in Python functions\nTo carry out common tasks with data and variables in Python, the language provides us with several built-in functions. Examples of built-in functions that we already used above are `print` and `type`. \n\n**Calling a function** \nWhen we want to make use of a function (referred to as calling the function), we type the name of the function followed by parentheses. Between the parentheses we can pass arguments.\n\n**Arguments**\nWe typically provide a function with 'arguments' to tell python which values or variables are used to perform the body of the function. In the example below `type` is the function name and `pi_value` is the argument.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ntype(pi_value)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nfloat\n```\n:::\n:::\n\n\nOther useful built-in functions are `abs()`, `max()`, `min()`, `range()`. Find more built-in functions [here](https://docs.python.org/3/library/functions.html).\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nmax([1,2,3,2,1])\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n3\n```\n:::\n:::\n\n\n## Boolean values, Logical expressions and operators\n\nIn programming you often need to know if something is `True` or `False`. `True` and `False` are called Boolean values and have their own data type (`bool` so they are not of type `str`!!). `True` and `False` are the only two Boolean values. \n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\na = True\na\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nb = False\nb\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nFalse\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ntype(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nbool\n```\n:::\n:::\n\n\nComparison operators (e.g. `>`, `<`, `==`) are used in an expression to compare two values. The result of this expression is either `True` or `False`. Why this is useful we will show later (see if-statements).\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n3 > 4\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nFalse\n```\n:::\n:::\n\n\n`3 > 4` is an example of a 'logical expression' (also known as condition), where `>` is the comparison operator. \n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n4 > 3\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nTrue\n```\n:::\n:::\n\n\n`==` is another comparison operator to check if two values or variables are the same. If this is the case it will return `True`\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nfour = 4          # first we create a variable\nfour == 4         # then we check if it is equal to 4\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\nTrue\n```\n:::\n:::\n\n\n`!=` is used to check if two values or variable are **not** the same. If this is the case it will return `True`\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nprint(\"Four is not equal to 5: \", four != 5)\nprint(\"Four is not equal to 4: \", four != 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFour is not equal to 5:  True\nFour is not equal to 4:  False\n```\n:::\n:::\n\n\n`and`, `or` and `not` are 'logical operators', and are used to join two logical expressions (or revert a logical expression in the case of `not`) to create more complex conditions. \n\n`and` will return `True` if both expression on either side are `True`.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\na = True\nb = True\na and b\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\na = True\nb = False\na and b\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nFalse\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n4 > 3 and 9 > 3\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nTrue\n```\n:::\n:::\n\n\n`or` is used to check if at least one of two logical expressions are `True`. If this is the case it will return `True`.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n3 > 4 or 9 > 3\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n4 > 3 or 9 > 3\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\nTrue\n```\n:::\n:::\n\n\nIn the last three examples you can see that multiple expressions can be combined in a single line of Python code. Python evaluates the expressions one by one. `4 > 3` would return `True`, `9 > 3` would return `True`, so `4 > 3 or 9 > 3` would translate to `True or True`.\n\nIt is also possible to assign the output of an expression to a variable:\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\ngreater = 3 > 4\nprint(\"3 > 4 : \", greater)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3 > 4 :  False\n```\n:::\n:::\n\n\nThe `not` operator can be used to reverse the Boolean value. If you apply `not` to an expression that evaluates to `True`, then you get `False` as a result. If you apply `not` to an expression that evaluates to `False`, then you get `True` as a result:\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nnot 4 > 3\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\nFalse\n```\n:::\n:::\n\n\n## Exercises\n\nNow go back to your browser to morning_exercises.ipynb and continue with exercises 1-3.\n\nWhen you finished the exercises, continue to chapter [Data types, if-statements and for loops](introduction_to_python_3.ipynb)\n\n",
    "supporting": [
      "Introduction_to_python_2_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}