{
  "hash": "c86ed638be868ecfff3e615c3ba3de92",
  "result": {
    "markdown": "---\ntitle: \"Variables and printing output\"\nexecute:   \n  enabled: true\n  error: true\n  freeze: auto\n---\n\n## Variables, values and their types\n\nThe cell below contains Python code that can be executed by the Python interpreter. One of the most basic things that we can do with Python is to use it as a calculator:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n2+2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4\n```\n:::\n:::\n\n\nGreat, but there are many calculators. It gets more interesting when we use **variables** to store information. This is done with the `=` operator.\nIn Python, variable names:\n- can include letters, digits, and underscores\n- cannot start with a digit\n- are case sensitive.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nx = 3.0\n```\n:::\n\n\nOnce assigned, variables can be used in new operations:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ny = 2.0\nx + y\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n5.0\n```\n:::\n:::\n\n\nPython knows various types of data. Three common ones are:\n\n- integer numbers\n- floating point numbers\n- strings\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ntext = \"Data Carpentry\"\nnumber = 42\npi_value = 3.14159265358\n```\n:::\n\n\nIn the example above, three variables are assigned. Variable `number` is an integer number with a value of 42 while `pi_value` is a floating point number and `text` is of type string.\n\nUsing the `type` command, it is possible to check the data type of a variable. \n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ntext\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n'Data Carpentry'\n```\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ntype(text)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nstr\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nnumber\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n42\n```\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ntype(number)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nint\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\npi_value\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n3.14159265358\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ntype(pi_value)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\nfloat\n```\n:::\n:::\n\n\n## Output versus printing\n\nIn the above examples, most of the times output is printed directly below the cell, but not always the output is printed and not all operations are printed. The `print` command can be used to control what is printed when. \n\n*Note*, that text (strings) always has to be surrounded by `\"` or `'`.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nprint(\"Hello World\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello World\n```\n:::\n:::\n\n\nIn the example below we first print the value of the variable `number` using the `print` command, and then call the variable:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nprint(number)\nnumber\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n42\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n42\n```\n:::\n:::\n\n\nNow we do it the other way around:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nnumber\nprint(number)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n42\n```\n:::\n:::\n\n\nWhen not using the `print` command, only the output of the last operation in the input cell is printed. If the last operation is the assignment of a variable, nothing will be printed. \n\nIn general `print` is the only way to print output to the screen when you are not working in an interactive environment like Jupyter (as we are doing now).\n\nRule of thumb: use the normal output for quick checking the output of an operation while developing in your Jupyter notebook, use `print` for printing output that still needs to be there in the future while your scripts get more complicated.\n\n## Exercises\n\nNow go to the Jupyter Dashboard in your internet browser and navigate to the course materials and open the notebook `morning_exercises.ipynb`\n\nIf Jupyter Dashboard is not there, check [Installation & Setup](installation-and-setup.qmd) for instructions to start the Jupyter Dashboard.\n\nDo Exercise 0 and after that come back to this document to continue with the following chapter [Operators and Built-in Functions](Introduction_to_python_2.ipynb)\n\n",
    "supporting": [
      "Introduction_to_python_1_files"
    ],
    "filters": [],
    "includes": {}
  }
}