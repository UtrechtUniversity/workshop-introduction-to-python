{
  "hash": "b2446e0aa57da9fcf65d8632d4f15bdb",
  "result": {
    "markdown": "---\ntitle: \"Introduction to python\"\nexecute:   \n  enabled: true\n  error: true\n  freeze: auto\n---\n\n# Introduction to python\n\n## Variables, values and their types\n\nThe cell below contains Python code that can be executed by the Python interpreter. One of the most basic things that we can do with Python is to use it as a calculator:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n2+2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4\n```\n:::\n:::\n\n\nGreat, but there are many calculators. It gets more interesting when we use **variables** to store information. This is done with the `=` operator.\nIn Python, variable names:\n- can include letters, digits, and underscores\n- cannot start with a digit\n- are case sensitive.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nx = 3.0\n```\n:::\n\n\nOnce assigned, variables can be used in new operations:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ny = 2.0\nx + y\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n5.0\n```\n:::\n:::\n\n\nPython knows various types of data. Three common ones are:\n\n- integer numbers\n- floating point numbers\n- strings\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ntext = \"Data Carpentry\"\nnumber = 42\npi_value = 3.14159265358\n```\n:::\n\n\nIn the example above, three variables are assigned. Variable `number` is an integer number with a value of 42 while `pi_value` is a floating point number and `text` is of type string.\n\nUsing the `type` command, it is possible to check the data type of a variable. \n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ntext\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n'Data Carpentry'\n```\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ntype(text)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nstr\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nnumber\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n42\n```\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ntype(number)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nint\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\npi_value\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n3.14159265358\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ntype(pi_value)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\nfloat\n```\n:::\n:::\n\n\n## Output versus printing\n\nIn the above examples, most of the times output is printed directly below the cell, but not always the output is printed and not all operations are printed. The `print` command can be used to control what is printed when. \n\n*Note*, that text (strings) always have to be surrounded by `\"` or `'`.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nprint(\"Hello World\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello World\n```\n:::\n:::\n\n\nIn the example below we first print the value of the variable `number` using the `print` command, and then call the variable:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nprint(number)\nnumber\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n42\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n42\n```\n:::\n:::\n\n\nNow we do it the other way around:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nnumber\nprint(number)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n42\n```\n:::\n:::\n\n\nWhen not using the `print` command, only the output of the last operation in the input cell is printed. If the last operation is the assignment of a variable, nothing will be printed. \n\nIn general `print` is the only way to print output to the screen when you are not working in an interactive environment as Jupyter (as we are doing now).\n\nRule of thumb: use the normal output for quick checking the output of an operation while developing in your Jupyter notebook, use `print` for printing output that still needs to be there in the future while your scripts get more complicated.\n\n## Mathematical operations\n\nIn Python you can do a wide variety of mathematical operations. A few examples:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nsumming = 2 + 2\nmultiply = 2 * 7\npower = 2 ** 16\nmodulo = 13 % 5\n\nprint(\"Sum: \", summing)\nprint(\"Multiply: \", multiply)\nprint(\"Power: \", power)\nprint(\"Modulo: \", modulo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSum:  4\nMultiply:  14\nPower:  65536\nModulo:  3\n```\n:::\n:::\n\n\nOnce we have data stored in variables, we can use the variables to do calculations.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nnumber = 42\npi_value = 3.14159265358\n\noutput = number * pi_value\nprint(output)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n131.94689145036\n```\n:::\n:::\n\n\n## Built-in Python functions\nTo carry out common tasks with data and variables in Python, the language provides us with several built-in functions. Examples of built-in functions that we already used above are `print` and `type`. \n\n**Calling a function** \nWhen we want to make use of a function (referred to as calling the function), we type the name of the function followed by parentheses. Between the parentheses we can pass arguments.\n\n**Arguments**\nWe typically provide a function with 'arguments' to tell python which values or variables are used to perform the body of the function. In the example below `type` is the function name and `pi_value` is the argument.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ntype(pi_value)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\nfloat\n```\n:::\n:::\n\n\nOther useful built-in functions are `abs()`, `max()`, `min()`, `range()`. Find more built-in functions [here](https://docs.python.org/3/library/functions.html).\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nmax([1,2,3,2,1])\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n3\n```\n:::\n:::\n\n\n## Boolean values, Logical expressions and operators\n\nIn programming you often need to know if something is `True` or `False`. `True` and `False` are called Boolean values and have their own data type (`bool` so they are not of type `str`!!). `True` and `False` are the only two Boolean values. \n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\na = True\na\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nb = False\nb\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\nFalse\n```\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\ntype(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\nbool\n```\n:::\n:::\n\n\nComparison operators (e.g. `>`, `<`, `==`) are used in an expression to compare two values. The result of this expression is either `True` or `False`. Why this is useful we will show later (see if-statements).\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n3 > 4\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\nFalse\n```\n:::\n:::\n\n\n`3 > 4` is an example of a 'logical expression' (as well known as condition), where `>` is the comparison operator. \n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n4 > 3\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\nTrue\n```\n:::\n:::\n\n\n`==` is another comparison operator to check if two values or variable are the same. If this is the case it will return `True`\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nfour = 4          # first we create a variable\nfour == 4         # then we check if it is equal to 4\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\nTrue\n```\n:::\n:::\n\n\n`!=` is used to check if two values or variable are **not** the same. If this is the case it will return `True`\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nprint(\"Four is not equal to 5: \", four != 5)\nprint(\"Four is not equal to 4: \", four != 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFour is not equal to 5:  True\nFour is not equal to 4:  False\n```\n:::\n:::\n\n\n`and`, `or` and `not` are 'logical operators', and are used to join two logical expressions to create more complex conditions. \n\n`and` will return `True` if both expression on either side are `True`.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\na = True\nb = True\na and b\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\na = True\nb = False\na and b\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\nFalse\n```\n:::\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n4 > 3 and 9 > 3\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\nTrue\n```\n:::\n:::\n\n\n`or` is used to check if at least one of two logical expressions are `True`. If this is the case it will return `True`.\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n3 > 4 or 9 > 3\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n4 > 3 or 9 > 3\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\nTrue\n```\n:::\n:::\n\n\nIn the last three examples you can see that multiple expressions can be combined in a single line of Python code. Python evaluates the expressions one by one. `4 > 3` would return `True`, `9 > 3` would return `True`, so `4 > 3 or 9 > 3` would translate to `True or True`.\n\nIt is also possible to assign the output of an expression to a variable:\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\ngreater = 3 > 4\nprint(\"3 > 4 : \", greater)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3 > 4 :  False\n```\n:::\n:::\n\n\n## The if-statement\n\nIf statements can be used to perform tasks only when a certain condition is met.\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nnum = 101\n\nif num > 100:\n    print('number is greater than 100')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nnumber is greater than 100\n```\n:::\n:::\n\n\nAs you can see, the line `print(...` starts with 4 spaces indentation.\nIn Python indentation is very important. Python uses indentation to determine which lines of code belong to what part of the code. This is mostly important when defining e.g. if-statements, for loops or functions. After the if condition, all lines with indentation are only performed when the if-condition is met.\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nnum = 99\nif num > 100:\n    print('This line is only executed when num > 100')\n    print('This line is only executed when num > 100')\n    \n    print('This line is only executed when num > 100')\n    \nprint('This line is always executed')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis line is always executed\n```\n:::\n:::\n\n\nIt is also possible to specify a task that is performed when the condition is not met using `else` (note the use of indentation):\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nnum = 37\n\nif num > 100:\n    print('number is greater than 100')\nelse:\n    print('number is not greater than 100')\n\nprint('done')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nnumber is not greater than 100\ndone\n```\n:::\n:::\n\n\nAn `if ... else` statement can be extended with `elif` to specify more tasks that need to be performed on other conditions. These extended `if ... else` statements always start with `if` and end with `else`. \n\n**Order matters**:\nThe statements (or conditions) are checked in order from top to bottom and only the task belonging to the first condition that is met is being performed. \n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\nnum = -3\n\nif num > 0:\n    print(num, 'is positive')\nelif num == 0:\n    print(num, 'is zero')\nelse:\n    print(num, 'is negative')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-3 is negative\n```\n:::\n:::\n\n\nERROR: Expected front matter to end with '---'\nAlong with the `>` and `==` comparison operators that we have already used for comparing values in our logical expressions above, there are a few more options to know about:\n\n- \\>: greater than\n- \\<: less than\n- ==: equal to\n- !=: does not equal\n- \\>=: greater than or equal to\n- \\<=: less than or equal to\n\nWe can combine logical statements using `and` and `or` in more complex conditions in if statements.\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\nif (1 < 0) or (1 >= 0):\n    print('at least one the above logical statements is true')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nat least one the above logical statements is true\n```\n:::\n:::\n\n\nWhile `and` is only true if both parts are true\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\nif (1 < 0) and (1 >= 0):\n    print('both tests are true')\nelse:\n    print('at least one of both tests is not true')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nat least one of both tests is not true\n```\n:::\n:::\n\n\n## Lists and Tuples\n\nUntil now we have worked with values and variables that hold one value or string. Now we will go into other data types that can combine multiple values or strings.\n\nLists are common data structures to hold a sequence of elements. We can create a list by putting values inside square brackets and separating the values with commas.\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\nnumbers = [1, 2, 3]\nprint(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3]\n```\n:::\n:::\n\n\nEach element can be accessed by an index. The index of the first element in a list in Python is 0 (in some other programming languages that would be 1).\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\nprint(\"The first element in the list numbers is: \", numbers[0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe first element in the list numbers is:  1\n```\n:::\n:::\n\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\ntype(numbers)\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\nlist\n```\n:::\n:::\n\n\nA total number of items in a list is called the 'length' and can be calculated using the `len()` function.\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\nlen(numbers)\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\n3\n```\n:::\n:::\n\n\nYou can do various things with lists. E.g. it is possible to sum the items in a list (when the items are all numbers)\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\nprint(\"The sum of the items in the list is:\", sum(numbers))\nprint(\"The mean of the items in the list is:\", sum(numbers)/len(numbers))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe sum of the items in the list is: 6\nThe mean of the items in the list is: 2.0\n```\n:::\n:::\n\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\nnumbers[3]\n```\n\n::: {.cell-output .cell-output-error}\n```\nIndexError: list index out of range\n```\n:::\n:::\n\n\nThis error is expected. The list consists of three items, and the indices of those items are 0, 1 and 2.\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\nnumbers[-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\n3\n```\n:::\n:::\n\n\nYes, we can use negative numbers as indices in Python. When we do so, the index -1 gives us the last element in the list, -2 the second to last, and so on. Because of this, numbers[2] and numbers[-1] point to the same element.\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\nnumbers[2] == numbers[-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\nTrue\n```\n:::\n:::\n\n\nIt is also possible to combine strings in a list:\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\nwords = [\"cat\", \"dog\", \"horse\"]\nwords[1]\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\n'dog'\n```\n:::\n:::\n\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\ntype(words)\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```\nlist\n```\n:::\n:::\n\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\nif type(words) == type(numbers):\n    print(\"these variables have the same type!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthese variables have the same type!\n```\n:::\n:::\n\n\nIt is also possible to combine values of different type (e.g. strings and integers) in a list\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\nnewlist = [\"cat\", 1, \"horse\"]\n```\n:::\n\n\nThe type of the variable newlist is `list`. The elements of the list have their own data type:\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\ntype(newlist[0])\n```\n\n::: {.cell-output .cell-output-display execution_count=49}\n```\nstr\n```\n:::\n:::\n\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\ntype(newlist[1])\n```\n\n::: {.cell-output .cell-output-display execution_count=50}\n```\nint\n```\n:::\n:::\n\n\nIt is possible to add numbers to an existing list using `list.append()`\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\nnumbers.append(4)\nprint(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4]\n```\n:::\n:::\n\n\nUsing the index of an item, you can replace the item in a list:\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\nnumbers[2] = 333\nprint(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 333, 4]\n```\n:::\n:::\n\n\nA tuple is similar to a list in that it’s a sequence of elements. However, tuples can not be changed once created (they are “immutable”). Tuples are created by placing comma-separated values inside parentheses `()` (instead of square brackets `[]`).\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\n# Tuples use parentheses\na_tuple = (1, 2, 3)\nanother_tuple = ('blue', 'green', 'red')\n\n# Note: lists use square brackets\na_list = [1, 2, 3]\n\n```\n:::\n\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\na_list[1] = 5\nprint(a_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 5, 3]\n```\n:::\n:::\n\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\na_tuple[1] = 5\nprint(a_tuple)\n```\n\n::: {.cell-output .cell-output-error}\n```\nTypeError: 'tuple' object does not support item assignment\n```\n:::\n:::\n\n\nHere we see that once the tuple is created, we cannot replace any of the values inside of the tuple.\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\ntype(a_tuple)\n```\n\n::: {.cell-output .cell-output-display execution_count=56}\n```\ntuple\n```\n:::\n:::\n\n\n## Dictionaries\n\nA dictionary is another way to store multiple items into one object. In dictionaries, however, this is done with keys and values. This can be useful for several reasons, one example is to store model settings, parameters or variable values for multiple scenarios.\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\nmy_dict = {'one': 'first', 'two': 'second'}\nmy_dict\n```\n\n::: {.cell-output .cell-output-display execution_count=57}\n```\n{'one': 'first', 'two': 'second'}\n```\n:::\n:::\n\n\nWe can access dictionary items by their key:\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\nmy_dict['one']\n```\n\n::: {.cell-output .cell-output-display execution_count=58}\n```\n'first'\n```\n:::\n:::\n\n\nAnd we can add new key-value pairs like that:\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\nmy_dict['third'] = 'three'\nmy_dict\n```\n\n::: {.cell-output .cell-output-display execution_count=59}\n```\n{'one': 'first', 'two': 'second', 'third': 'three'}\n```\n:::\n:::\n\n\nDictionary items are ordered, changeable, and do not allow duplicates.\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\nmy_dict['third'] = 'three'\nmy_dict\n```\n\n::: {.cell-output .cell-output-display execution_count=60}\n```\n{'one': 'first', 'two': 'second', 'third': 'three'}\n```\n:::\n:::\n\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\nprint(\"Dictionary keys: \", my_dict.keys())\nprint(\"Dictionary values: \", my_dict.values())\nprint(\"Dictionary items (key, value): \", my_dict.items())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDictionary keys:  dict_keys(['one', 'two', 'third'])\nDictionary values:  dict_values(['first', 'second', 'three'])\nDictionary items (key, value):  dict_items([('one', 'first'), ('two', 'second'), ('third', 'three')])\n```\n:::\n:::\n\n\n## For loops\nLet's have a look at our list again. One way to print each number is to use three print statements:\n\n::: {.cell execution_count=62}\n``` {.python .cell-code}\nnumbers = [5, 6, 7]\nprint(numbers[0])\nprint(numbers[1])\nprint(numbers[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n6\n7\n```\n:::\n:::\n\n\nA more efficient (less typing) and reliable way to print each element of a list is to loop over the list using a for loop:\n\n::: {.cell execution_count=63}\n``` {.python .cell-code}\nfor item in numbers:\n    print(item)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n6\n7\n```\n:::\n:::\n\n\nThe improved version uses a for loop to repeat an operation — in this case, printing — once for each item in a sequence. Note that (similar to if statements) Python needs indentation (4 whitespaces) to determine which lines of code are part of the for loop.\n\nIf we want to also get the index, we can use the built-in function enumerate:\n\n::: {.cell execution_count=64}\n``` {.python .cell-code}\nwords = [\"cat\", \"dog\", \"horse\"]\n\nfor index, item in enumerate(words):\n    print(index)\n    print(item)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\ncat\n1\ndog\n2\nhorse\n```\n:::\n:::\n\n\nFor loops can also be used with dictionaries. Let's take our dictionary from the previous section and inspect the dictionary items\n\n::: {.cell execution_count=65}\n``` {.python .cell-code}\nfor item in my_dict.items():\n    print(item, \"is of type\", type(item))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n('one', 'first') is of type <class 'tuple'>\n('two', 'second') is of type <class 'tuple'>\n('third', 'three') is of type <class 'tuple'>\n```\n:::\n:::\n\n\nWe can extract the keys and values from the items directly in the `for` statement:\n\n::: {.cell execution_count=66}\n``` {.python .cell-code}\nfor key, value in my_dict.items():\n    print(key, \"->\", value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\none -> first\ntwo -> second\nthird -> three\n```\n:::\n:::\n\n\n## Functions\n\nWe have already seen some built-in functions: e.g. `print`, `type`, `len`. And we have seen special functions that belong to a variable (python object) like `my_dict.items()` and `my_list.append()`. There are more built-in functions e.g. for mathematical operations:\n\n::: {.cell execution_count=67}\n``` {.python .cell-code}\nsum(numbers)\n```\n\n::: {.cell-output .cell-output-display execution_count=67}\n```\n18\n```\n:::\n:::\n\n\nPlease refer to https://docs.python.org/3/library/functions.html for more built-in functions.\n\n### Writing own functions\nWe will now turn to writing own functions. When should you write your own function?  \n1. If the functionality is not covered by an out-of-the-box function like the built-in functions or another python  package  \n2. When code is getting pretty long, you can split it up into logical and reusable units  \n3. When code is often reused, e.g. you are reading in tens of spreadsheets and you need to clean them all in the same way. Instead of typing the line of code over and over again, it is more elegant and looks cleaner to create a function.  \n4. When code may be reused outside your current project. Scripts and the functions in a script can be imported in other scripts to be able to reuse them.  \n\nA big advantage of not having duplicate code inside your script or in multiple scripts is that when you want to make a slight modification to a function, you only have to do this modification in one place, instead of multiple lines that are doing more or less similar things.\n\nPython provides for this by letting us define things called ‘functions’. Let’s start by defining a function fahr_to_celsius that converts temperatures from Fahrenheit to Celsius:\n\n::: {.cell execution_count=68}\n``` {.python .cell-code}\ndef fahr_to_celsius(temp_fahrenheit):\n    temp_celsius = (temp_fahrenheit - 32) * (5/9)\n    return temp_celsius\n```\n:::\n\n\nThe function definition opens with the keyword `def` followed by the name of the function `fahr_to_celsius` and a parenthesized list of variables (in this case only one `(temp)`). The body of the function — the statements that are executed when it runs — is indented below the definition line. The body concludes with a `return` keyword followed by the return value.\n\nWhen we call the function, the values we pass to it as arguments are assigned to the variables in the function definition so that we can use them inside the function. Inside the function, we use a return statement to send a result back to whoever asked for it.\n\nLet’s try running our function.\n\n::: {.cell execution_count=69}\n``` {.python .cell-code}\nfahr_to_celsius(98)\n```\n\n::: {.cell-output .cell-output-display execution_count=69}\n```\n36.66666666666667\n```\n:::\n:::\n\n\n::: {.cell execution_count=70}\n``` {.python .cell-code}\nprint('freezing point of water:', fahr_to_celsius(32), 'C')\nprint('boiling point of water:', fahr_to_celsius(212), 'C')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfreezing point of water: 0.0 C\nboiling point of water: 100.0 C\n```\n:::\n:::\n\n\nHere we directly opassed a value to the function. We can also call the function with a variable:\n\n::: {.cell execution_count=71}\n``` {.python .cell-code}\na = 0\nprint(fahr_to_celsius(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-17.77777777777778\n```\n:::\n:::\n\n\nWhat happens if you pass a variable name that is not defined yet?\n\n::: {.cell execution_count=72}\n``` {.python .cell-code}\nprint(fahr_to_celsius(b))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-17.77777777777778\n```\n:::\n:::\n\n\n",
    "supporting": [
      "python-101_files"
    ],
    "filters": [],
    "includes": {}
  }
}